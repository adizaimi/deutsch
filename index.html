<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Deutsch Words</title>
    <link rel="manifest" href="/manifest.json">
    <style>
        body {
            margin: 0;
            padding: 0;
            overflow: hidden;
            font-family: Arial, sans-serif;
            text-align: center;
        }
        .container {
            align: center;
            border: 2px solid lightyellow;
            display: flex;
            flex-direction: column;
        }
        .word {
            padding: 10px;
            background-color: #f0f0f0;
            border: 1px solid #ccc;
            border-radius: 5px;
            font-size: 20px;
            user-select: none;
        }
        .on {
            background-color: #80c080; /* Color for 'selected' box */
            transition: background-color 0s ease; /* Smooth transition */
        }
    </style>
</head>
<body>
  <audio id="wordAudio" src=""></audio>
  <table class="container" id="entireField">
      <tr class="container"><td>  </td></tr>
      <tr class="container"><td><div class="word" id="topEl"></div></td></tr>
      <tr class="container"><td><div class="word" id="bottomEl"></div></td></tr>
  </table>
<table id="accuracyMapTbl" class='accmap' align="center" ></table>
<div id="index">blah</div>

<script src="wl.js"></script>
<script>

/* Define your pairs of symbols
const pairs = [
    { key: 'a/A', value: 'a, A' },
    { key: 'b', value: 'B' },
    { key: 'c', value: 'C' },
    { key: 'd', value: 'D' },
    { key: 'e', value: 'E' },
    { key: 'f', value: 'F' },
    { key: 'g', value: 'G' },
    { key: 'h', value: 'H' },
    { key: 'i', value: 'I' },
    { key: 'j', value: 'J' },
    { key: 'k', value: 'K' },
    { key: 'l', value: 'L' },
    { key: 'm', value: 'M' },
    { key: 'n', value: 'N' },
    { key: 'o', value: 'O' },
    { key: 'p', value: 'P' },
    { key: 'q', value: 'Q' },
    { key: 'r', value: 'R' },
    { key: 's', value: 'S' },
    { key: 't', value: 'T' },
    { key: 'u', value: 'U' },
    { key: 'v', value: 'V' },
    { key: 'w', value: 'W' },
    { key: 'x', value: 'X' }
]; */


function getEl(elName) {
    return document.getElementById(elName);
}

function getRandomPair() {
    const randomIndex = Math.floor(Math.random() * pairs.length);
    return pairs[randomIndex];
}

function pickRandomSplitEntry (str, splitChar) {
    const entries = str.split(splitChar);
    if (entries.length < 2)
        return str;
    //console.log(entries); // debug print the pairs
    const trimmedEntries = entries.map(item=>item.trim());
    //console.log(trimmedEntries); // debug print the pairs
    const randomIndex = Math.floor(Math.random() * trimmedEntries.length);
    //console.log(randomIndex); // debug print the pairs
    return trimmedEntries[randomIndex];
}

function createWordElement(text, isKey) {
    const div = document.createElement('div');
    div.className = 'word';
    div.style.width = `${(window.innerWidth - 30)}px`;
    div.textContent = text.trim();
    div.style.left = `20px`; // Avoid edges
    if (isKey) {
        div.style.top = `20px`;
        //div.addEventListener('click', () => playWordSound(div));
    } else
        div.style.top = `150px`;
    return div;
}

function showCurrentPair() {
    const pair = shuffledPairs[currentIndex];
    if (pair == undefined) {
        console.log("Pair is undefined");
        console.log(pair);
        throw("Pair is undefined");
    }
    const keyEl = getEl('topEl');
    const valueEl = getEl('bottomEl');
    keyEl.textContent = pickRandomSplitEntry(pair.key, '/');
    valueEl.textContent = pickRandomSplitEntry(pair.value, ',');
    getEl('index').textContent = `${currentIndex}`;
}

function showNextPair() {
    console.log("showNextPair()");
    currentIndex = (currentIndex + 1) % shuffledPairs.length;
    showCurrentPair();
}

function showPreviousPair() {
    currentIndex = (currentIndex - 1 + shuffledPairs.length) % shuffledPairs.length;
    showCurrentPair();
}

// For desktop: click as next
document.body.addEventListener('click', e => {
    if (!e.touches) { // Avoid double trigger on touch devices
        showNextPair();
    }
});

function sleep(ms) {
    return new Promise(resolve => setTimeout(resolve, ms));
}

async function playWordSound(el) {
    var text = el.textContent.trim().replace(/\s*\(pl\)\s*/gi, '');
    if (false) {
        console.log('Try via direct connection.');
        const audioUrl = `https://translate.google.com/translate_tts?ie=UTF-8&tl=de&q=${encodeURIComponent(text)}&client=tw-ob`;
        fetch(audioUrl)
            .then(response => {
                console.log('Response ', response.json());
            })
            .then(data => {
                console.log('Download complete:', data.file);
                return;
            })
            .catch(error => {
                console.log('Error Encountered: ' + error);
            });
    }

    if (false) {
        console.log('Will try via the proxy forward way');
        const audioUrl = `translate_tts?ie=UTF-8&tl=de&q=${encodeURIComponent(text)}&client=tw-ob`;
        /* delay does not do anything
         * fetch(audioUrl);
         * await sleep(2000);
         * console.log('after 2s');
         */
        fetch(audioUrl)
            .then(response => {
                console.log('Response ', response);
                if (!response.ok) {
                    throw new Error('Network response was not ok');
                }
                return response.blob();
            })
            .then(data => {
                console.log('Download complete:', data.file);
                var abc = new Audio(URL.createObjectURL(blob)); // Create an Audio object from the Blob
                abc.play(); // Play the audio
            })
            .catch(error => {
                console.log('Error Encountered: ' + error);
            });
    }

    if (true) {
        console.log('Trigger server running Node to download mp3 file if not cached.');
        fetch(`local_tts?word=${encodeURIComponent(text)}`)
        .then(response => response.json())
        .then(data => {
            console.log('Download complete:', data.file);

            //const audioUrl = `/tts_cache/${encodeURIComponent(text)}.mp3`;
            const audioUrl = `/tts_cache/${encodeURIComponent(text.replace(/\s*/gi, ""))}.mp3`;
            console.log('Loading audio url ' + audioUrl);

            const audio = new Audio(audioUrl);
            audio.play().catch(err => {
                console.error('Audio playback error:', err);
                alert('Error playing sound: ' + err.message);
            });
            return;
        })
        .catch(error => console.error(error));
    }

    if ('speechSynthesis' in window) {
        const utterance = new SpeechSynthesisUtterance(text);
        utterance.lang = 'de-DE'; // Set to German
        utterance.volume = 1.0; // 0 to 1
        utterance.rate = 0.8; // 0.1 to 10
        utterance.pitch = 1.1; // 0 to 2

        // Optionally select a specific voice
        const voices = window.speechSynthesis.getVoices();
        const germanVoice = voices.find(voice => voice.lang === 'de-DE');
        if (germanVoice) {
            utterance.voice = germanVoice; // Use German voice (e.g., Siriâ€™s Anna)
        }

        // Play the speech
        window.speechSynthesis.speak(utterance);

        // Log for debugging
        console.log('Playing TTS for:', text);
    } else {
        console.error('SpeechSynthesis not supported');
        alert('Text-to-speech is not supported in this browser.');
    }
}

function setUp() {
    const field = getEl('entireField');
    field.style.width = `${(window.innerWidth)}px`;
    field.style.height = `${(window.innerHeight) - 40}px`;

    const topEl = getEl('topEl');
    topEl.addEventListener('click', (event) => {
        event.stopPropagation();
        playWordSound(topEl);
        topEl.classList.add('on');
        setTimeout(() => { topEl.classList.remove('on'); }, 300);
    });

    topEl.addEventListener('touchend', (event) => {
        event.stopPropagation();
        event.preventDefault();
        playWordSound(topEl);
        topEl.classList.add('on');
        setTimeout(() => { topEl.classList.remove('on'); }, 300);
    });

    topEl.addEventListener('touchend', (event) => {
    });

    // Touch events for swipe and tap
    document.body.addEventListener('touchstart', e => {
        touchStartX = e.changedTouches[0].screenX;
    });

    document.body.addEventListener('keyPress', e => {
        console.log(e);
    });

    document.body.addEventListener('touchend', e => {
        const touchEndX = e.changedTouches[0].screenX;
        const deltaX = touchEndX - touchStartX;

        if (Math.abs(deltaX) <= 20) {
            // Tap: do nothing, click even will handle
        } else if (deltaX > 20) {
            // Swipe right: previous
            showPreviousPair();
        } else if (deltaX < -20) {
            // Swipe left: next
            showNextPair();
        }
    });
}

let shuffledPairs = [...pairs].sort(() => Math.random() - 0.5); // Shuffle the pairs once
let currentIndex = 0;
let touchStartX = 0;
setUp();

// Initial display
window.onload = showCurrentPair;

</script>

</body>
</html>
