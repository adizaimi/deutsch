<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Deutsch Words</title>
    <link rel="manifest" href="/manifest.json">
    <style>
        body {
            margin: 0;
            padding: 0;
            overflow: hidden;
            font-family: Arial, sans-serif;
            text-align: center;
        }
        .container {
            border: 2px solid lightyellow;
            display: flex;
            flex-direction: column;
            align-items: center;
        }
        .word {
            padding: 10px;
            background-color: #f0f0f0;
            border: 1px solid #ccc;
            border-radius: 5px;
            font-size: 20px;
            user-select: none;
        }
        .on {
            background-color: #80c080; /* Color for 'selected' box */
            transition: background-color 0s ease; /* Smooth transition */
        }
        .autospeak-toggle {
            position: fixed;
            bottom: 20px;
            left: 20px;
            width: 45px;
            height: 22px;
            background-color: #ccc;
            border-radius: 11px;
            border: none;
            cursor: pointer;
            transition: all 0.3s ease;
            z-index: 1000;
            position: relative;
            outline: none;
        }
        
        .autospeak-toggle::before {
            content: '';
            position: absolute;
            top: 2px;
            left: 2px;
            width: 18px;
            height: 18px;
            background-color: white;
            border-radius: 50%;
            transition: all 0.3s ease;
            box-shadow: 0 2px 4px rgba(0,0,0,0.2);
        }
        
        .autospeak-toggle.on {
            background-color: #4CAF50;
        }
        
        .autospeak-toggle.on::before {
            transform: translateX(23px);
        }
        
        .autospeak-toggle.off {
            background-color: #f44336;
        }
        
        .autospeak-toggle.off::before {
            transform: translateX(0px);
        }
        
        .autospeak-toggle:hover {
            box-shadow: 0 4px 8px rgba(0,0,0,0.3);
        }
    </style>
</head>
<body>
  <audio id="wordAudio" src=""></audio>
  <table class="container" id="entireField">
      <tr class="container"><td>  </td></tr>
      <tr class="container"><td><div class="word" id="topEl"></div></td></tr>
      <tr class="container"><td><div class="word" id="bottomEl"></div></td></tr>
  </table>
<table id="accuracyMapTbl" class='accmap' align="center" ></table>
<div id="counterField">blah</div>
<br>
<div id="toggle">><button class="autospeak-toggle" id="autospeakToggle">autospeak</button></div>

<script src="wl.js"></script>
<script>

/* Define your pairs of symbols
const pairs = [
    { key: 'a/A', value: 'a, A' },
    { key: 'b', value: 'B' },
    { key: 'c', value: 'C' },
    { key: 'd', value: 'D' },
    { key: 'e', value: 'E' },
    { key: 'f', value: 'F' },
    { key: 'g', value: 'G' },
    { key: 'h', value: 'H' },
    { key: 'i', value: 'I' },
    { key: 'j', value: 'J' },
    { key: 'k', value: 'K' },
    { key: 'l', value: 'L' },
    { key: 'm', value: 'M' },
    { key: 'n', value: 'N' },
    { key: 'o', value: 'O' },
    { key: 'p', value: 'P' },
    { key: 'q', value: 'Q' },
    { key: 'r', value: 'R' },
    { key: 's', value: 'S' },
    { key: 't', value: 'T' },
    { key: 'u', value: 'U' },
    { key: 'v', value: 'V' },
    { key: 'w', value: 'W' },
    { key: 'x', value: 'X' }
]; */


function getEl(elName) {
    return document.getElementById(elName);
}

function getRandomPair() {
    const randomIndex = Math.floor(Math.random() * pairs.length);
    return pairs[randomIndex];
}

function pickRandomSplitEntry (str, splitChar) {
    const entries = str.split(splitChar);
    if (entries.length < 2)
        return str;
    //console.log(entries); // debug print the pairs
    const trimmedEntries = entries.map(item=>item.trim());
    //console.log(trimmedEntries); // debug print the pairs
    const randomIndex = Math.floor(Math.random() * trimmedEntries.length);
    //console.log(randomIndex); // debug print the pairs
    return trimmedEntries[randomIndex];
}

function createWordElement(text, isKey) {
    const div = document.createElement('div');
    div.className = 'word';
    div.style.width = `${(window.innerWidth - 30)}px`;
    div.textContent = text.trim();
    div.style.left = `20px`; // Avoid edges
    if (isKey) {
        div.style.top = `20px`;
    } else
        div.style.top = `150px`;
    return div;
}

function showCurrentPair() {
    const pair = shuffledPairs[currentIndex];
    if (pair == undefined) {
        console.log("Pair is undefined");
        console.log(pair);
        throw("Pair is undefined");
    }
    const keyEl = getEl('topEl');
    const valueEl = getEl('bottomEl');
    if (nextWord != '') {
        keyEl.textContent = nextWord;
    } else {
        var txt = pickRandomSplitEntry(pair.key, '/');
        keyEl.textContent = txt.trim().replace(/\s*\(pl\)\s*/gi, '');
    }
    valueEl.textContent = pickRandomSplitEntry(pair.value, ',');
    getEl('counterField').textContent = `${currentIndex}`;

    if (autospeakEnabled) {
        playWordSound(getEl('topEl'));

        var txt = pickRandomSplitEntry(shuffledPairs[currentIndex + 1].key, '/');
        nextWord = txt.trim().replace(/\s*\(pl\)\s*/gi, '');

        console.log('Pre-Fetching TTS for next word:', nextWord);
        fetch(`local_tts?word=${encodeURIComponent(nextWord)}`)
            .then(response => {
                console.log('Response ', response);
            })
            .catch(error => {
                console.error(error);
            });
    }
}

function showNextPair() {
    console.log("showNextPair()");
    currentIndex = (currentIndex + 1) % shuffledPairs.length;
    showCurrentPair();
}

function showPreviousPair() {
    currentIndex = (currentIndex - 1 + shuffledPairs.length) % shuffledPairs.length;
    showCurrentPair();
}

// For desktop: click as next
document.body.addEventListener('click', e => {
    if (!e.touches) { // Avoid double trigger on touch devices
        showNextPair();
    }
});

function sleep(ms) {
    return new Promise(resolve => setTimeout(resolve, ms));
}

function playWordSound(el) {
    var text = el.textContent;
    if (false) {
        var success = false;
        console.log('Try via direct connection.');
        const audioUrl = `https://translate.google.com/translate_tts?ie=UTF-8&tl=de&q=${encodeURIComponent(text)}&client=tw-ob`;
        fetch(audioUrl)
            .then(response => {
                console.log('Response ', response);
            })
            .then(data => {
                console.log('Download complete:', data);
                success = true;
            })
            .catch(error => {
                console.log('Error Encountered: ' + error);
            });
        if (success) return;
    }

    if (false) {
        console.log('Will try via the proxy forward way');
        const audioUrl = `translate_tts?ie=UTF-8&tl=de&q=${encodeURIComponent(text)}&client=tw-ob`;
        /* delay does not do anything
         * fetch(audioUrl);
         * await sleep(2000);
         * console.log('after 2s');
         */
        fetch(audioUrl)
            .then(response => {
                console.log('Response ', response);
                if (!response.ok) {
                    throw new Error('Network response was not ok');
                }
                return response.blob();
            })
            .then(data => {
                console.log('Download complete:', data.file);
                var abc = new Audio(URL.createObjectURL(blob)); // Create an Audio object from the Blob
                abc.play(); // Play the audio
            })
            .catch(error => {
                console.log('Error Encountered: ' + error);
            });
    }

    if (true) {
        console.log(`Trigger server running Node to download {encodeURIComponent(text)}.mp3 file if not cached.`);
        fetch(`local_tts?word=${encodeURIComponent(text)}`)
        .then(response => response.json())
        .then(data => {
            console.log('Download complete:', data.file);

            const audioUrl = `/tts_cache/${encodeURIComponent(text.replace(/\s*/gi, ""))}.mp3`;
            console.log('Loading audio url ' + audioUrl);

            const audio = new Audio(audioUrl);
            audio.play().catch(err => {
                console.error('Audio playback error:', err);
                alert('Error playing sound: ' + err.message);
            });
            return;
        })
        .catch(error => {
            console.error(error);
            if (false && 'speechSynthesis' in window) {
                const utterance = new SpeechSynthesisUtterance(text);
                utterance.lang = 'de-DE'; // Set to German
                utterance.volume = 1.0; // 0 to 1
                utterance.rate = 0.8; // 0.1 to 10
                utterance.pitch = 1.1; // 0 to 2

                // Optionally select a specific voice
                const voices = window.speechSynthesis.getVoices();
                const germanVoice = voices.find(voice => voice.lang === 'de-DE');
                if (germanVoice) {
                    utterance.voice = germanVoice; // Use German voice (e.g., Siriâ€™s Anna)
                }

                // Play the speech
                window.speechSynthesis.speak(utterance);

                // Log for debugging
                console.log('Playing TTS for:', text);
            } else {
                console.error('SpeechSynthesis not supported');

            }
        });
    }
}

function setup() {
    const field = getEl('entireField');
    field.style.width = `${(window.innerWidth)}px`;
    field.style.height = `${(window.innerHeight) - 40}px`;

    // Set up autospeak toggle button
    const autospeakToggle = getEl('autospeakToggle');
    autospeakToggle.addEventListener('click', function(event) {
        event.stopPropagation(); // Prevent triggering next word
        autospeakEnabled = !autospeakEnabled;
        if (autospeakEnabled) {
            autospeakToggle.classList.remove('off');
            autospeakToggle.classList.add('on');
        } else {
            autospeakToggle.classList.remove('on');
            autospeakToggle.classList.add('off');
        }
    });

    const topEl = getEl('topEl');
    topEl.addEventListener('click', (event) => {
        event.stopPropagation();
        playWordSound(topEl);
        topEl.classList.add('on');
        setTimeout(() => { topEl.classList.remove('on'); }, 300);
    });

    topEl.addEventListener('touchend', (event) => {
        event.stopPropagation();
        event.preventDefault();
        playWordSound(topEl);
        topEl.classList.add('on');
        setTimeout(() => { topEl.classList.remove('on'); }, 300);
    });

    topEl.addEventListener('touchend', (event) => {
    });

    // Touch events for swipe and tap
    document.body.addEventListener('touchstart', e => {
        touchStartX = e.changedTouches[0].screenX;
    });

    document.body.addEventListener('keyPress', e => {
        console.log(e);
    });

    document.body.addEventListener('touchend', e => {
        const touchEndX = e.changedTouches[0].screenX;
        const deltaX = touchEndX - touchStartX;

        if (Math.abs(deltaX) <= 20) {
            // Tap: do nothing, click even will handle
        } else if (deltaX > 20) {
            // Swipe right: previous
            showPreviousPair();
        } else if (deltaX < -20) {
            // Swipe left: next
            showNextPair();
        }
    });

    // Initialize toggle button state
    getEl('autospeakToggle').classList.add(autospeakEnabled ? 'on' : 'off');
}

let shuffledPairs = [...pairs].sort(() => Math.random() - 0.5); // Shuffle the pairs once
let currentIndex = 0;
let touchStartX = 0;
let autospeakEnabled = false;
let nextWord = '';
setup();

// Initial display
window.onload = function() {
    showCurrentPair();
};

</script>

</body>
</html>
